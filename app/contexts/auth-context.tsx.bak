"use client"

import React, { createContext, useContext, useState, useEffect, ReactNode } from "react"
import { useRouter } from "next/navigation"
import { toast } from "react-hot-toast"
import { 
  storeUserData, 
  getUserData, 
  clearUserData, 
  User, 
  storeAuthToken,
  getAuthToken,
  clearAuthToken,
  verifyToken
} from "@/app/utils/auth"

interface AuthContextType {
  user: User | null
  token: string | null
  loading: boolean
  error: string | null
  login: (email: string, password: string, redirectUrl?: string) => Promise<void>
  logout: () => Promise<void>
  checkAuth: () => Promise<boolean>
  validateCurrentToken: () => Promise<boolean>
  updateUserData?: (data: Partial<User>) => void
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

interface AuthProviderProps {
  children: ReactNode
}

export function AuthProvider({ children }: AuthProviderProps) {
  const [user, setUser] = useState<User | null>(null)
  const [token, setToken] = useState<string | null>(null)
  const [loading, setLoading] = useState<boolean>(true)
  const [error, setError] = useState<string | null>(null)
  const router = useRouter()

  // Check if user is already logged in on mount
  useEffect(() => {
    const initAuth = async () => {
      await checkAuth()
      setLoading(false)
    }
    initAuth()
  }, [])

  const login = async (email: string, password: string, redirectUrl?: string) => {
    try {
      setLoading(true)
      setError(null)

      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ email, password }),
        credentials: "include" // Important for cookie handling
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.message || "Login failed")
      }

      // Save token
      const authToken = data.data.token
      setToken(authToken)
      
      // Store token in localStorage
      storeAuthToken(authToken)
      
      // Log authentication status
      console.log("Login successful, token stored:", authToken ? "Yes" : "No")

      // If user data is included in the login response, use it directly
      if (data.data.user) {
        const userData = data.data.user;
        
        // Save the user information in state and persistent storage
        setUser(userData)
        storeUserData(userData)
        
        // Show success toast
        toast.success("Logged in successfully")
        
        // Force cookie check - this helps ensure cookies are properly set before redirect
        // This can help with production environments where cookie handling may be different
        document.cookie = `auth-token-check=true; path=/; max-age=3600;`;
        
        // Wait briefly to ensure cookies are set
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Redirect to appropriate page (dashboard by default)
        if (redirectUrl) {
          router.push(redirectUrl)
          // Fallback redirect in case Next.js router fails
          setTimeout(() => {
            if (window.location.pathname !== redirectUrl) {
              window.location.href = redirectUrl;
            }
          }, 1000);
        } else {
          router.push("/dashboard")
          // Fallback redirect in case Next.js router fails
          setTimeout(() => {
            if (window.location.pathname !== "/dashboard") {
              window.location.href = "/dashboard";
            }
          }, 1000);
        }
        return;
      }

      // Otherwise, validate the token to get user info (fallback)
      const validationResponse = await validateToken(authToken)
      if (validationResponse.data.valid) {
        const userData = validationResponse.data.user;
        setUser(userData)
        storeUserData(userData)
        
        // Show success toast
        toast.success("Logged in successfully")
        
        // Redirect to appropriate page (dashboard by default)
        if (redirectUrl) {
          router.push(redirectUrl)
          // Fallback redirect in case Next.js router fails
          setTimeout(() => {
            if (window.location.pathname !== redirectUrl) {
              window.location.href = redirectUrl;
            }
          }, 1000);
        } else {
          router.push("/dashboard")
          // Fallback redirect in case Next.js router fails
          setTimeout(() => {
            if (window.location.pathname !== "/dashboard") {
              window.location.href = "/dashboard";
            }
          }, 1000);
        }
      }
    } catch (err: any) {
      setError(err.message || "Failed to login")
      toast.error(err.message || "Failed to login")
    } finally {
      setLoading(false)
    }
  }

  const logout = async () => {
    try {
      setLoading(true)
      
      // Set a temporary cookie to indicate logout in progress
      document.cookie = "logging-out=true; path=/; max-age=5";
      
      // Call logout API
      await fetch("/api/auth/logout", {
        method: "POST",
        credentials: "include" // Important for cookie handling
      })
      
      // Clear auth state
      setUser(null)
      setToken(null)
      
      // Clear stored data
      clearAuthToken()
      clearUserData()
      
      // Clear cookies manually as a backup
      document.cookie = "auth-token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT";
      
      // Show success toast
      toast.success("Logged out successfully")
      
      // Wait briefly to ensure cookies are fully cleared
      await new Promise(resolve => setTimeout(resolve, 500))
      
      // Redirect to login page with force reload to clear any cached state
      window.location.href = "/login";
    } catch (err: any) {
      setError(err.message || "Failed to logout")
      toast.error(err.message || "Failed to logout")
    } finally {
      setLoading(false)
    }
  }

  const checkAuth = async (): Promise<boolean> => {
    try {
      // Apply debouncing to checkAuth as well to reduce validation frequency
      const now = Date.now()
      if (checkAuth.lastChecked && now - checkAuth.lastChecked < 30000) { // 30 seconds
        // console.log("Auth checked recently, using cached result:", checkAuth.lastResult)
        return checkAuth.lastResult
      }
      
      // First check if we have user data in storage
      const storedUser = getUserData()
      const storedToken = getAuthToken()
      
      if (storedUser && storedToken) {
        // If we already have the user data, use it
        setUser(storedUser)
        setToken(storedToken)
        
        // Try local token validation first to avoid unnecessary API calls
        try {
          const decoded = verifyToken(storedToken)
          if (decoded) {
            checkAuth.lastChecked = now
            checkAuth.lastResult = true
            return true
          }
        } catch (localError) {
          // If local validation fails, continue to API validation
        }
        
        // Only validate with external API if local validation fails
        const isValid = await validateCurrentToken()
        checkAuth.lastChecked = now
        checkAuth.lastResult = isValid
        
        if (!isValid) {
          // If token is invalid, clear user data but don't log out immediately
          // This prevents immediate redirects and gives UI time to handle the state
          setTimeout(() => {
            if (!validateCurrentToken.lastResult) {
              clearAuthToken()
              clearUserData()
              setUser(null)
              setToken(null)
            }
          }, 1000)
          return false
        }
        
        return true
      } else if (storedToken) {
        // If we have a token but no user data, validate the token
        
        // Check if we already have a user with this token to prevent unnecessary API calls
        if (user && token === storedToken) {
          // Try local validation first
          try {
            const decoded = verifyToken(storedToken)
            if (decoded) {
              checkAuth.lastChecked = now
              checkAuth.lastResult = true
              return true
            }
          } catch (localError) {
            // If local validation fails, continue to API validation
          }
          
          // Only validate with external API if local validation fails
          const isValid = await validateCurrentToken()
          checkAuth.lastChecked = now
          checkAuth.lastResult = isValid
          
          if (!isValid) {
            // If token is invalid, clear user data but don't log out immediately
            setTimeout(() => {
              if (!validateCurrentToken.lastResult) {
                clearAuthToken()
                clearUserData()
                setUser(null)
                setToken(null)
              }
            }, 1000)
            return false
          }
          
          return true
        }

        // Validate the token
        const validationResponse = await validateToken(storedToken)
        
        if (validationResponse.data?.valid && validationResponse.data?.user) {
          const userData = validationResponse.data.user;
          setToken(storedToken)
          setUser(userData)
          storeUserData(userData)
          checkAuth.lastChecked = now
          checkAuth.lastResult = true
          return true
        } else {
          // Clear invalid token but don't log out immediately
          setTimeout(() => {
            clearAuthToken()
            clearUserData()
          }, 1000)
          checkAuth.lastChecked = now
          checkAuth.lastResult = false
          return false
        }
      }
      
      checkAuth.lastChecked = now
      checkAuth.lastResult = false
      return false
    } catch (err) {
      console.error("Auth check failed:", err)
      return false
    }
  }
  
  // Add static properties to the function for debouncing
  checkAuth.lastChecked = 0
  checkAuth.lastResult = false

  const validateCurrentToken = async (): Promise<boolean> => {
    try {
      const currentToken = token || getAuthToken()
      
      if (!currentToken) {
        return false
      }
      
      // Add more aggressive debouncing to prevent multiple API calls in short succession
      // This uses a static lastValidated variable in the function's closure
      const now = Date.now()
      if (validateCurrentToken.lastValidated && 
          now - validateCurrentToken.lastValidated < 60000) { // Increase to 60 seconds
        // console.log("Token validated recently, using cached result:", validateCurrentToken.lastResult)
        return validateCurrentToken.lastResult
      }
      
      // Add local token validation before making an API call
      try {
        const decoded = verifyToken(currentToken)
        if (decoded) {
          // If the token is valid locally, we can avoid the API call
          validateCurrentToken.lastValidated = now
          validateCurrentToken.lastResult = true
          return true
        }
      } catch (localError) {
        // If local validation fails, continue to API validation
        console.error("Local token validation failed:", localError)
      }
      
      // console.log("Validating token with external API")
      // Validate with external API
      try {
        const response = await fetch('/api/auth/validate-token', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ token: currentToken }),
          // Add timeout to prevent hanging requests
          signal: AbortSignal.timeout(5000)
        })
        
        if (!response.ok) {
          validateCurrentToken.lastValidated = now
          validateCurrentToken.lastResult = false
          return false
        }

        const data = await response.json()
        
        // Check if the response contains a valid field
        if (typeof data.valid === 'undefined') {
          console.error("Invalid API response format:", data)
          validateCurrentToken.lastValidated = now
          validateCurrentToken.lastResult = false
          return false
        }
        
        const result = !!data.valid
        // console.log("External token validation result:", result)
        
        // Cache the result
        validateCurrentToken.lastValidated = now
        validateCurrentToken.lastResult = result
        
        // If valid and user data is included, update user context
        if (result && data.user && updateUserData) {
          updateUserData(data.user)
        }
        
        return result
      } catch (fetchError) {
        console.error("External API call failed:", fetchError)
        
        // If the API call fails, fall back to local token validation
        // This prevents logout loops when the API is unavailable
        try {
          const decoded = verifyToken(currentToken)
          if (decoded) {
            // If the token is still valid locally, consider it valid
            validateCurrentToken.lastValidated = now
            validateCurrentToken.lastResult = true
            return true
          }
        } catch (fallbackError) {
          // If local validation fails again, token is invalid
          console.error("Fallback validation failed:", fallbackError)
        }
        
        validateCurrentToken.lastValidated = now
        validateCurrentToken.lastResult = false
        return false
      }
    } catch (error) {
      console.error("Token validation failed:", error)
      return false
    }
  }
  
  // Add static properties to the function
  validateCurrentToken.lastValidated = 0
  validateCurrentToken.lastResult = false

  const validateToken = async (token: string) => {
    const response = await fetch("/api/auth/validate-token", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ token }),
    })

    const data = await response.json()
    return data
  }

  const updateUserData = (data: Partial<User>) => {
    if (user) {
      const updatedUser = { ...user, ...data }
      setUser(updatedUser)
      storeUserData(updatedUser)
    }
  }

  const contextValue: AuthContextType = {
    user,
    token,
    loading,
    error,
    login,
    logout,
    checkAuth,
    validateCurrentToken,
    updateUserData
  }

  return (
    <AuthContext.Provider value={contextValue}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider")
  }
  return context
} 